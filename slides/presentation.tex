\documentclass{beamer}
\usepackage{fontspec} 
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usetheme{Warsaw}
\title[Three Scala solutions]{Three Scala solutions\\How to make your Scala controll effects a-la Haskell}
\author{George Leontiev}
\institute{folone.info}
\date{February 28, 2013}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


\begin{frame}{Introduction}
  Note: I intentionally made it more "interesting" to show more neat scalaz stuff\newline
  I won't cover everything though. If something seems strange, please ask.
\end{frame}

\begin{frame}[fragile]
\frametitle{Core}
Main functions
\begin{lstlisting}[mathescape]
wordCount :: String → Map (String, Int)
acceptedChars :: Char → Boolean
\end{lstlisting}
Helper functions
\begin{lstlisting}[mathescape]
time :: (a → IO b) → IO b
close :: Closeable a $\Rightarrow$ a → IO ()
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Core}
\begin{lstlisting}[mathescape]
def acceptedChars(c: Char) = {
  val sum: (((Boolean, Boolean), Boolean)) $\Rightarrow$
    Boolean = _ match {
      case ((a, b), c) ⇒ a || b || c
    }
  val fun = ((_: Char).isLetterOrDigit) &&&
            ((_: Char).isWhitespace)    &&&
            ((_: Char) == '-')
  (fun >>> sum)(c)
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Core}
\begin{lstlisting}[mathescape]
def wordCount(text: String): Map[String, Int] =
  text.filter(acceptedChars)
       // split words
      .toLowerCase.split("\\W").toList
      // Optionally parallelize
      .par
      // group
      .groupBy(identity)
      // calculate group sizes
      .map { case(key, value) $\Rightarrow$
        key.trim → -value.length
      }
      // Get results from parallel computation
      .seq
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Typeclass instances}
\begin{lstlisting}[mathescape]
val N = 10
implicit val mapInstances = new Show[List[(String, Int)]] {
  override def shows(l: List[(String, Int)]) =
    l.filterNot(_._1.isEmpty)
      .sortBy(_._2)
      .take(N)
      .foldLeft("") { case(acc, (key, value)) $\Rightarrow$
        acc + "\n" + key + ": " + (-value)
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Executing}
\begin{lstlisting}[mathescape]
  // function :: String → IO String
  def main(args: Array[String]) = {
    val path   = args(0)
    val action = for {
      result ← time(function(path))
      _      ← putStrLn(result)
    } yield ()
    // Yuck!
    action.unsafePerformIO()
  }
\end{lstlisting}
\end{frame}

\begin{frame}{All set}
  Let's see how far we can push this solution.
\end{frame}

\begin{frame}[fragile]
\frametitle{First attempt}
\begin{lstlisting}[mathescape]
  def wholeFile(path: String): IO[String] =
    IO { Source.fromFile(path) }.bracket(close) {
      source $\Rightarrow$
        IO {
          val text   = source.mkString
          val result = wordCount(text)
          result.toList.shows
        }
    }
\end{lstlisting}
\end{frame}

\begin{frame}{First attempt}
  Works fine, but eats all the heap on a large enouth file.
\end{frame}

\begin{frame}[fragile]
\frametitle{Second attempt}
\begin{lstlisting}[mathescape]
  def byLine(path: String): IO[String] =
    IO { Source.fromFile(path) }.bracket(close) {
      source $\Rightarrow$
        IO {
          val stream = source.getLines.toStream
          val result = stream.map(wordCount)
            .foldLeft(Map.empty[String, Int]) {
              case(acc, v) $\Rightarrow$ acc |+| v
          }
          result.toList.shows
        }
    }
\end{lstlisting}
\end{frame}

\begin{frame}{Second attempt}
  Just what is this |+|?
\end{frame}

\begin{frame}[fragile]
\frametitle{Typeclasses}
\begin{lstlisting}[mathescape]
  instance Show [(String, Int)] where ...
  instance Show Monoid b $\Rightarrow$ Map a b where ...
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Monoids}
$(S, \otimes, 1)$\newline
$\forall a, b \in S: a \otimes b \in S$\newline
$\forall a, b, c \in S: (a \otimes b) \otimes c = a \otimes (b \otimes c)$\newline
$\forall a \in S: 1 \otimes a = a \otimes 1 = a$\newline
\end{frame}

\begin{frame}{Second attempt}
  Pretty good, but can we do better?
\end{frame}

\begin{frame}[fragile]
\frametitle{Iteratees}
\begin{lstlisting}[mathescape]
def getFileLines[A](f: File,
  m: Process[String, A]): Procedure[IO, A] =
    new Procedure[IO, A] {
      type K = String $\Rightarrow$ Any
      val machine = m
      def withDriver[R](k: Driver[IO, K] $\Rightarrow$
        IO[R]): IO[R] = {
          bufferFile(f).bracket(close)(r $\Rightarrow$ {
            val d = new Driver[IO, String $\Rightarrow$ Any] {
              val M = Monad[IO]
              def apply(k: String $\Rightarrow$ Any) =
              rReadLn(r) map (_ map k)
            }
            k(d)
          })
        }
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Iteratees}
\begin{lstlisting}[mathescape]
def bufferFile(f: File): IO[BufferedReader] =
  IO { new BufferedReader(new FileReader(f)) }

  /** Read a line from a buffered reader */
def rReadLn(r: BufferedReader):IO[Option[String]] =
  IO { Option(r.readLine) }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Iteratees}
\begin{lstlisting}[mathescape]
  def wordFreq(path: String) =
    getFileLines(new File(path),
      id outmap wordCount) execute
\end{lstlisting}
\end{frame}

\begin{frame}{Wordcounting at large}
\begin{enumerate}
  \item[Scoobi] http://nicta.github.com/scoobi/
  \item[Spark] http://spark-project.org/
  \item[Scalding] https://github.com/twitter/scalding/wiki/Type-safe-api-reference
\end{enumerate}
\end{frame}

\begin{frame}{Wordcounting}
  Turns out, this code will work for these "as is".
\end{frame}

\end{document}
