\documentclass{beamer}
\usepackage{fontspec} 
\usepackage{listings}
\usetheme{Warsaw}
\title[Three Scala solutions]{Three Scala solutions\\How to make your Scala controll effects a-la Haskell}
\author{George Leontiev}
\institute{folone.info}
\date{February 28, 2013}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


\begin{frame}{Introduction}
  Note: I intentionally made it more "interesting" to show more neat scalaz stuff\newline
  I won't cover everything though. If something seems strange, please ask.
\end{frame}

\begin{frame}[fragile]
\frametitle{Core}
Main functions
\begin{lstlisting}
wordCount :: String → Map (String, Int)
acceptedChars :: Char → Boolean
splitWords :: String → [String]
\end{lstlisting}
Helper functions
\begin{lstlisting}
time :: (a → IO b) → IO b
close :: Closeable a ⇒ a → IO ()
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Core}
\begin{lstlisting}
def acceptedChars(c: Char) = {
  val sum: (((Boolean, Boolean), Boolean)) =>
    Boolean = _ match {
      case ((a, b), c) ⇒ a || b || c
    }
  val fun = ((_: Char).isLetterOrDigit) &&&
            ((_: Char).isWhitespace)    &&&
            ((_: Char) == '-')
  (fun >>> sum)(c)
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Core}
\begin{lstlisting}
def splitWords(text: String): List[String] =
  text.filter(acceptedChars)
      .toLowerCase.split("\\W").toList

def wordCount(text: String): Map[String, Int] =
  splitWords(text)
      // Optionally parallelize
      .par
      // group
      .groupBy(identity)
      // calculate group sizes
      .map { case(key, value) =>
        key.trim → -value.length
      }
      // Get results from parallel computation
      .seq
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Executing}
\begin{lstlisting}
  // function :: String → IO String
  def main(args: Array[String]) = {
    val path   = args(0)
    val action = for {
      result ← time(function(path))
      _      ← putStrLn(result)
    } yield ()
    // Yuck!
    action.unsafePerformIO()
  }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{First attempt}
\begin{lstlisting}
  def wholeFile(path: String): IO[String] =
    IO { Source.fromFile(path) }.bracket(close) {
      source =>
        IO {
          val text   = source.mkString
          val result = wordCount(text)
          result.toList.shows
        }
    }
\end{lstlisting}
\end{frame}

\begin{frame}{First attempt}
  Works fine, but eats all the heap on a large enouth file.
\end{frame}

\begin{frame}[fragile]
\frametitle{Second attempt}
\begin{lstlisting}
  def byLine(path: String): IO[String] =
    IO { Source.fromFile(path) }.bracket(close) {
      source =>
        IO {
          val stream = source.getLines.toStream
          val result = stream.map(wordCount)
            .foldLeft(Map.empty[String, Int]) {
              case(acc, v) => acc |+| v
          }
          result.toList.shows
        }
    }
\end{lstlisting}
\end{frame}

\begin{frame}{Second attempt}
  Just what is this |+|?
\end{frame}

\begin{frame}[fragile]
\frametitle{Typeclasses}
\begin{lstlisting}
  implicit val mapInstances =
    new Show[List[(String, Int)]]
    with Monoid[List[(String, Int)]]

    is the same as

  instance Show [(String, Int)] where ...
  instance Monoid [(String, Int)] where ...
\end{lstlisting}
\end{frame}

\begin{frame}{Second attempt}
  Pretty good, but can we do better?
\end{frame}

\begin{frame}[fragile]
\frametitle{Iteratees}
\begin{lstlisting}
def getFileLines[A](f: File,
  m: Process[String, A]): Procedure[IO, A] =
    new Procedure[IO, A] {
      type K = String => Any
      val machine = m
      def withDriver[R](k: Driver[IO, K] =>
        IO[R]): IO[R] = {
          bufferFile(f).bracket(close)(r => {
            val d = new Driver[IO, String => Any] {
              val M = Monad[IO]
              def apply(k: String => Any) =
              rReadLn(r) map (_ map k)
            }
            k(d)
          })
        }
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Iteratees}
\begin{lstlisting}
def bufferFile(f: File): IO[BufferedReader] =
  IO { new BufferedReader(new FileReader(f)) }

  /** Read a line from a buffered reader */
def rReadLn(r: BufferedReader):IO[Option[String]] =
  IO { Option(r.readLine) }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Iteratees}
\begin{lstlisting}
  def wordFreq(path: String) =
    getFileLines(new File(path),
      id outmap wordCount) execute
\end{lstlisting}
\end{frame}

\begin{frame}{Wordcounting at large}
\begin{enumerate}
  \item[Scoobi] http://nicta.github.com/scoobi/
  \item[Spark] http://spark-project.org/
  \item[Scalding] https://github.com/twitter/scalding/wiki/Type-safe-api-reference
\end{enumerate}
\end{frame}

\begin{frame}{Wordcounting}
  Turns out, this code will work for these "as is".
\end{frame}

\end{document}
